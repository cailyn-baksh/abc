<!DOCTYPE html>
<html>
	<head>
		<title>Intermediate Representation | ABC Docs</title>

		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<aside>
			<div>
				<iframe src="sidebar.html"></iframe>
			</div>
		</aside>
		<main>
			<p>
				The IR is a pseudo-machine code format designed for a virtual
				machine which is designed to abstract away the details of
				specific architectures. It is effectively an
				architecture-neutral machine code. The IR is an ultra-RISC
				architecture based on the ARM, x86, and Z80 architectures.
			</p>
			<p>
				Despite being RISC, the IR provides addressing modes more like
				CISC architectures, albeit somewhat more limited. Registers and
				indirected registers may both be read from and written to, and
				memory addresses and PC-relative offsets can be read from by
				all instructions.
			</p>
			<p>
				Although the specifics are up to the frontends generating the
				IR, the general idea is for literals to be encoded as literal
				pools which are referenced using PC-relative offsets. Short
				jumps (within 32768 bytes) can be encoded as jumps to a
				PC-relative offset, and longer jumps can be encoded as a 31-bit
				offset from the beginning of the program. There are no
				provisions to enable programs larger than 2147483648 bytes.
				External symbols are encoded as immediate strings in the IR, to
				be dealt with by the backend or linker. Memory addresses, while
				not directly dereferencable, can be loaded into a register and
				then dereferenced.
			</p>
			<p>
				In total, the architecture has 16 instructions and 8 registers.
				Seven of these registers are general purpose, and one is a cell
				pointer. There is no concrete program counter as the
				architecture provides no direct method to manipulate with the
				program counter. The flags register, while also not concrete,
				is defined as having the Zero, Negative (or sign), Overflow,
				and Carry flags present. This architecture is fully Turing
				complete and is theoretically capable of being implemented on
				all extant CPU architectures.
			</p>
			<p>
				Since this architecture is designed with esoteric languages in
				mind, memory is treated as a 1-dimensional tape. This is taken
				from the popular esoteric language Brainfuck, arguably the most
				popular and well-known esoteric language and one upon which the
				overwhelming majority of esoteric languages designed since have
				based their own abstract memory systems on. Since this IR is a
				layer closer to the hardware than most programming languages
				(especially most esoteric ones), the memory tape is bounded to
				a discrete range rather than being infinite in size, however
				addresses loop around. This means that decrementing the cell
				pointer below zero will cause it to point to the “top” of
				memory, and incrementing it past the top will cause it to point
				to zero. This is a feature which can be optionally disabled in
				high-performance applications.
			</p>

			<h2 id="ir-instruction-fmt">IR Instruction Format</h2>
			<p>
				IR instructions are incredibly compact, able to be as small as
				a single byte. Instructions are variable length, starting with
				an instruction byte which specifies how many bytes follow.
				<i>Figure 1</i> shows the layout of the instruction byte. The
				high four bits contain the opcode (<i>Figure 2</i>). The low
				four bits encode the two operands (<i>Figure 3</i>).
			</p>
			<figure>
				<table class="grid">
					<thead>
						<tr>
							<th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td colspan="4">Opcode</td>
							<td>Op1</td>
							<td colspan="2">Op2</td>
							<td>Reserved</td>
						</tr>
					</tbody>
				</table>
				<figcaption>Figure 1: Instruction Byte Layout</figcaption>
			</figure>
			<p>
				For detailed documentation of each opcode, as well as suggested
				pseudo-instructions that make up for otherwise missing
				instructions, see <a target="_top" href="ir-instructions.html">IR Instructions</a>.
			</p>
			<figure>
				<table class="list">
					<thead>
						<tr>
							<th>Opcode</th>
							<th>Instruction</th>
							<th>Opcode</th>
							<th>Instruction</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<th><code>0x0</code></th>
							<td>Jump</td>
	
							<th><code>0x8</code></th>
							<td>OR</td>
						</tr>
						<tr>
							<th><code>0x1</code></th>
							<td>Add</td>
	
							<th><code>0x9</code></th>
							<td>XOR</td>
						</tr>
						<tr>
							<th><code>0x2</code></th>
							<td>Subtract</td>
	
							<th><code>0xA</code></th>
							<td>One's Complement</td>
						</tr>
						<tr>
							<th><code>0x3</code></th>
							<td>Multiply</td>
	
							<th><code>0xB</code></th>
							<td>Logical Left Shift</td>
						</tr>
						<tr>
							<th><code>0x4</code></th>
							<td>Divide</td>
	
							<th><code>0xC</code></th>
							<td>Logical Right Shift</td>
						</tr>
						<tr>
							<th><code>0x5</code></th>
							<td>Compare</td>
	
							<th><code>0xD</code></th>
							<td>Arithmetic Right Shift</td>
						</tr>
						<tr>
							<th><code>0x6</code></th>
							<td>Test</td>
	
							<th><code>0xE</code></th>
							<td>Move</td>
						</tr>
						<tr>
							<th><code>0x7</code></th>
							<td>AND</td>
	
							<th><code>0xF</code></th>
							<td>Call</td>
						</tr>
					</tbody>
				</table>
				<figcaption>Figure 2: Opcodes</figcaption>
			</figure>
			<p>
				The low nybble of the instruction byte encodes the two operands
				Operand 1 only uses the first operand two codes.
			</p>
			<p>
				A register parameter affects the value stored in a register. A
				register indirect dereferences an address stored in a register.
				A memory address parameter uses a memory address. Memory
				addresses cannot be dereferenced directly, and must be loaded
				into registers to access their values. PC-relative offsets
			</p>
			<figure>
				<table class="list">
					<thead>
						<tr>
							<th>Code</th>
							<th>Type</th>
							<th>Meaning</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>0b00</code></td>
							<td>Register</td>
							<td style="text-align: left;">
								A value stored in a register.
							</td>
						</tr>
						<tr>
							<td><code>0b01</code></td>
							<td>Register Indirect</td>
							<td style="text-align: left;">
								Dereferences a memory address stored in a
								register.
							</td>
						</tr>
						<tr>
							<td><code>0b10</code></td>
							<td>Memory Address</td>
							<td style="text-align: left;">
								Either a signed 31-bit absolute offset from the
								beginning of the program, or a null terminated
								string. Absolute offsets begin with a set bit
								(total length is 32 bits). Strings indicate an
								external symbol that to be resolved at link
								time.
							</td>
						</tr>
						<tr>
							<td><code>0b11</code></td>
							<td>PC-Relative Offset</td>
							<td style="text-align: left;">
								A read only value stored at a fixed signed
								16-bit offset from the beginning of the
								instruction.
							</td>
						</tr>
					</tbody>
				</table>
				<figcaption>Figure 3: Operand Type Encoding</figcaption>
			</figure>
			<p>
				After the instruction byte comes a variable number of argument
				bytes, which contain the values of the arguments. Values in the
				argument bytes are packed together; the bits appear directly
				adjacent to one another unless byte alignment is otherwise
				specified.
			</p>

			<h3 id="reg-encode">Register Encoding</h3>
			<p>
				Register encodings, as shown in <i>Figure 4</i>, are used for
				both Register and Register Indirect arguments. Registers are
				encoded in three bit sequences, with no padding. The two
				special registers are <code>AR</code> (the Address Register)
				and <code>LR</code> (the Link Register). These names are just
				suggestions and they can also be used as numbered general
				registers.
			</p>
			<figure>
				<table class="list">
					<thead>
						<tr>
							<th>Code</th>
							<th>Register</th>
							<th>Code</th>
							<th>Register</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<th><code>0b000</code></th>
							<td>R0</td>

							<th><code>0b100</code></th>
							<td>R4</td>
						</tr>
						<tr>
							<th><code>0b001</code></th>
							<td>R1</td>

							<th><code>0b101</code></th>
							<td>R5</td>
						</tr>
						<tr>
							<th><code>0b010</code></th>
							<td>R2</td>

							<th><code>0b110</code></th>
							<td>R6 / AR</td>
						</tr>
						<tr>
							<th><code>0b011</code></th>
							<td>R3</td>

							<th><code>0b111</code></th>
							<td>R7 / LR</td>
						</tr>
					</tbody>
				</table>
				<figcaption>Figure 4: Register Encodings</figcaption>
			</figure>

			<h3 id="mem-addr-encode">Memory Address Encoding</h3>
			<p>
				Memory addresses are encoded in one of two ways. If the first
				bit of the address is set, then the next 31 bits are an offset
				from the beginning of the program. If the first bit is clear,
				then it is the beginning of a null-terminated string specifying
				the name of an external symbol.
			</p>

			<h3 id="pc-rel-encode">PC-Relative Offsets</h3>
			<p>
				PC-relative offsets are encoded as signed 16-bit values, which
				are added to the address of the beginning of this instruction
				to yield the address of the value.
			</p>

			<h3 id="cond-codes">Condition Codes</h3>
			<p>
				Some instructions take condition code arguments. Condition
				codes are four bytes long in total. The first bit is the negate
				bit which, if zero, indicates the condition should be negated.
				The remaining three bits specify the condition. Condition codes
				have no padding.
			</p>
			<figure>
				<table class="list">
					<thead>
						<tr>
							<th>Code</th>
							<th>Condition</th>
							<th>Mnemonic</th>
							<th>Negated Condition</th>
							<th>Mnemonic</th>
						</tr>
					</thead>
					<tbody style="font-family:serif">
						<tr>
							<td><code>0b000</code></td>
							<td>1</td>
							<td><code>al</code></td>
							<td>0</td>
							<td>-</td>
						</tr>
						<tr>
							<td><code>0b001</code></td>
							<td>Z</td>
							<td><code>eq</code> <code>z</code></td>
							<td>&not;Z</td>
							<td><code>ne</code> <code>nz</code></td>
						</tr>
						<tr>
							<td><code>0b010</code></td>
							<td>C</td>
							<td><code>cs</code> <code>hs</code></td>
							<td>&not;C</td>
							<td><code>cc</code> <code>lo</code></td>
						</tr>
						<tr>
							<td><code>0b011</code></td>
							<td>N</td>
							<td><code>mi</code></td>
							<td>&not;Z</td>
							<td><code>pl</code></td>
						</tr>
						<tr>
							<td><code>0b100</code></td>
							<td>V</td>
							<td><code>o</code></td>
							<td>&not;V</td>
							<td><code>no</code></td>
						</tr>
						<tr>
							<td><code>0b101</code></td>
							<td>C &and; &not;Z</td>
							<td><code>hi</code></td>
							<td>&not;C &or; Z</td>
							<td><code>ls</code></td>
						</tr>
						<tr>
							<td><code>0b110</code></td>
							<td>N = V</td>
							<td><code>ge</code></td>
							<td>N &ne; V</td>
							<td><code>lt</code></td>
						</tr>
						<tr>
							<td><code>0b111</code></td>
							<td>N = V &and; &not;Z</td>
							<td><code>gt</code></td>
							<td>N &ne; V &or; Z</td>
							<td><code>le</code></td>
						</tr>
					</tbody>
				</table>
				<figcaption>Condition Codes</figcaption>
			</figure>

			<h3>Operand Size Specifier</h3>
			<p>
				Some instructions will require that their operand size be
				specified. This is done using the operand size specifier, which
				is a 2-bit value that is used to calculate the size in bytes of
				the operands. The size of the operands is equal to
				<span style="font-family:serif">2<sup>size</sup></span>.
				Operand Size Specifiers do not affect the values in a register
				(but they do affect register indirect values).
			</p>
		</main>
	</body>
</html>